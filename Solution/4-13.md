# 如何统计数组元素的频率
可以用unordered_map来统计，其用法如下：
```cpp
unordered_map<int, int> count;
//如果5不存在，则初始值为0
count[5]++;
for (auto i : count) {
  cout << i.first << " " << i.second << endl;
}
```
用unordered_map相对于数组的优势是其节省空间。
TODO: to implement unordered_map, and add a link here to the implement

# 旋转数组的二分查找
什么是旋转数组，假如 a = [0, 1, 2, 3, 4]。以下标2进行旋转后的数组为 [2,3,4,0,1]。
如何进行二分查找呢？有这样一个发现，以任何索引去切分旋转数组，总有一部分是有序的，而且有序和无序的判断只需要判断区间两端元素的大小即可。
这时候就可以判断目标值是不是在有序的那一部分，来缩小查找空间，实现O(logn)的查找算法。

# 下一个字典序的数
我们把由固定的几个数字构成的数叫做字典数，如[1,2,3,4,6]可以构成12346， 12463等数组
给我们一个字典数，如何得到下一个字典序的数呢？
有这样一个结论：最大的字典数，从第一位到最后一位是递减的。
还有一个结论，将靠前的值变得更大，会使得字典数变大更多，我们要求的下一个字典数，需要在靠后的位置做改动。
假设a[i]就是我们要修改的最靠前的值，我们需要将这个最靠前的值尽可能地靠后。
我们可以从后往前查找，第一个满足a[i] < a[i+1]的数，如果这样的话，a[i]就是我们要修改的最靠前的值。[i+1, n-1]中必定存在一个最小的数a[j], 满足a[i]< a[j]。
交换a[i]、a[j]，该字典数就比以前大了，但是还不是下一个。观察此时的[i+1, n-1]必是递减的序列。用双指针反转即可，都不用排序。
